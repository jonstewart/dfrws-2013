/*

Last Updated: 06 December 2012
Version     : 1.5

Updated By  : Lightbox Technologies, Inc.
              http://www.lightboxtechnologies.com
              info@lightboxtechnologies.com

Author      : Yogesh Khatri
              42 LLC
              Yogesh@42LLC.net

For         : Sgt. Glenn Lang
              Maine State Police
              207-877-8081
              glang@mcctf.org

*/

class MainClass;

/* CarveSizeDialogClass
   This class represents a dialog that dynamically
   changes the number of controls it displays
   depending on the number of unique extensions
   in the input file provided.
*/
class CarveSizeDialogClass : DialogClass {
  typedef String[]          StringArray;
  typedef StringEditClass[] StringEditArray;
  typedef int[]             IntArray;
  typedef IntEditClass[]    IntEditArray;

  NameValueClass  Items;
  StringArray     Strings;
  IntArray        Ints;
  StringEditArray StringEdits;
  IntEditArray    IntEdits;
  StaticTextClass Text1,
                  Text2;

  CarveSizeDialogClass(NameValueClass items):
    DialogClass(null, "Define Keyword offset for extensions"),
    Items = items,
    Strings(0, items.Count()),
    Ints(0, items.Count()),
    StringEdits(0, items.Count()),
    IntEdits(0, items.Count()),
    Text1(this, "Extension", 20, 10, 40, 12, 0),
    Text2(this, "Keyword Offset(Bytes)", NEXT, SAME, 100, 12, 0)
  {
    CreateEditBoxes();
  }

  void CreateEditBoxes() {

    int x = 20, y = 25;

    uint numItems = Items.Count();
    for (int i = 0; i < numItems; ++i) {
      Strings.Add(Items.GetChild(i).Name());
      Ints.Add(int::Convert(Items.GetChild(i).Value()));
      StringEdits.Add(new StringEditClass(this, "", x, y, 40, 10, READONLY, Strings[i], 128, 0));
      IntEdits.Add(new IntEditClass(this, "", x + 55, y, 80, 10, 0, Ints[i], 0, 1073741824, REQUIRED));

      y += 15;
    }
  }

  virtual bool CanClose() {
    if (DialogClass::CanClose()) {
      Output();
      uint numItems = Items.Count();
      for (int i = 0; i < numItems; ++i) {
        Items.GetChild(i).SetValue(Ints[i]);
      }
      return true;
    }
    return false;
  }
}

class MainDialogClass : DialogClass {

  PathEditClass   OutputFilePath;
  StaticTextClass Info;

  MainDialogClass(MainClass main):
    DialogClass(null, MainClass::ScriptName() + " - v " + MainClass::Version()),
    OutputFilePath(this, "Output file path", START, START, 280, DEFAULT, 0, main.OutputFilePath, REQUIRED | FILECREATE, "Ini Files\t*.ini\tAll Files\t*.*"),
#ifdef VERSION_7
    Info(this, "After clicking OK, you will be prompted to select the tag name(s).\n\nIf you have not tagged any entries, please hit Cancel and do so before starting.", START, NEXT, 280, 25, 0)
#else
    Info(this, "Select all entries in encase from which you wish to extract keywords, then press OK to continue", START, NEXT, 280, 25, 0)
#endif
  {
  }
}

class MainClass {

  String OutputFilePath;

  static String ScriptName() {
    return "Create Input file for Search & Carve Script";
  }

  static String Version() {
    return "3.1";
  }

  void EditStorage(StorageClass s) {
    s.Value("OutputFilePath", OutputFilePath);
  }

  void Load() {
    StorageClass s(MainClass::ScriptName());
    EditStorage(s);
  }

  void Save() {
    StorageClass s(MainClass::ScriptName(), StorageClass::WRITE);
    EditStorage(s);
  }

  /* This function displays a dialog to the user where extension offsets
     are to be populated. The retrieved information is then passed onto
     the required data structures (SearchTerms).
  */

  String GetKeyword(EntryClass e, uint offset) {
    String keyword;
    EntryFileClass file();
    if (file.Open(e)) {
      file.Seek(offset);
      for (int i = 0; i < 10; ++i) {
        int onebyte = file.ReadBinaryInt(1);
        keyword += "\\x" + String::FormatInt(onebyte, int::HEX, 0, 2);
      }
      file.Close();
    }
    else
      Console.WriteLine("Error , could not open file " + e.FullPath());
    return keyword;
  }

  void addToList(NameValueClass nv, const String& ext) {
    if (!nv.Find(ext)) {
      new NameValueClass(nv, ext, 0, "10"); // Converts search term extension to NameValue object for dialog
    }
  }

  void generateKeywords(NameValueClass nv, EntryClass e, uint& total, FileClass outputFile) {
    NameValueClass n = nv.Find(e.Extension());
    if (n) {
      uint offset = uint::Convert(n.Value()); // populate searchterm object from NameValue object
      if (offset == 0 ) Console.WriteLine("Warning : Offset was zero for entry = " + e.FullPath());
      String keyword = GetKeyword(e, offset);
      if (!keyword) {
        Console.WriteLine("Error, keyword could not be extracted");
      }
      else {
        outputFile.Write(keyword + "\t" +
                         e.Extension() + "\t" +
                         offset + "\t" +
                         e.LogicalSize() + "\r\n"
                         );
        total++;
      }
    }
    else {
      Console.WriteLine("Error, could not find value for entry " + e.FullPath());
    }
  }

  uint GetExtensionInfo(CaseClass c, FileClass outputFile) {
    uint total;
    NameValueClass nv();
#ifdef VERSION_7
    ItemIteratorClass iter(c, ItemIteratorClass::PROMPT | ItemIteratorClass::NOPROXY, ItemIteratorClass::TAGGED);
    if (!iter.Name()) {
      Console.WriteLine("No tags were selected, nothing to do");
      return 0;
    }
    SystemClass::StatusMessage("Getting extensions");
    while (EntryClass e = iter.GetNextEntry()) {
      if (!e.IsFolder() && !e.IsInternal() && !e.IsUnallocated()) {
        addToList(nv, e.Extension());
      }
    }
#else
    SystemClass::StatusMessage("Getting extensions");
    forall (EntryClass e in c.EntryRoot()) {
      if (e.IsSelected() && !e.IsFolder() && !e.IsInternal() && !e.IsUnallocated()) {
        addToList(nv, e.Extension());
      }
    }
#endif
    CarveSizeDialogClass d(nv);
    SystemClass::StatusMessage("Waiting for dialog input. Check taskbar for dialog!");
    if (d.Execute() == SystemClass::OK) { // display dialog
    SystemClass::StatusMessage("Writing file");
    ulong count;
#ifdef VERSION_7
      iter.Open(c, ItemIteratorClass::NOPROXY, ItemIteratorClass::TAGGED, iter.Name()); //reset with same tag selections
      while (EntryClass e = iter.GetNextEntry()) {
        if (!e.IsFolder() && !e.IsInternal() && !e.IsUnallocated()) {
          ++count;
          SystemClass::StatusMessage("Writing file (" + count + " lines)");
          generateKeywords(nv, e, total, outputFile);
        }
      }
#else
      forall (EntryClass e in c.EntryRoot()) {
        if (e.IsSelected() && !e.IsFolder() && !e.IsInternal() && !e.IsUnallocated()) {
          ++count;
          SystemClass::StatusMessage("Writing file (" + count + " lines)");
          generateKeywords(nv, e, total, outputFile);
        }
      }
#endif
    }
    return total;
  }

  void Main(CaseClass c) {
    Load();
    bool good = true;
    if (!c) {
      SystemClass::Message(SystemClass::ICONEXCLAMATION, "No Case", "There is no case active, please open a case.");
      good = false;
    }
#ifdef VERSION_7
    if (c.HasEvidenceList()==0) {
      SystemClass::Message(SystemClass::ICONEXCLAMATION, "No Evidence", "You do not appear to have evidence in your case.\n\nPlease load some evidence first.");
      good = false;
    }
#else
    if (!c.EntryRoot() || !c.EntryRoot().FirstChild() || !c.EntryRoot().FirstChild().FirstChild()) {
      SystemClass::Message(SystemClass::ICONEXCLAMATION, "Nothing loaded", "No evidence present in this case!\nPlease load some evidence first.");
      good = false;
    }
#endif
    if (good) {
      MainDialogClass dialog(this);
      if (dialog.Execute() != SystemClass::CANCEL) {
        Save();
        SystemClass::ClearConsole();
        LocalFileClass outputfile();
        if (outputfile.Open(OutputFilePath, FileClass::WRITE | FileClass::TEXT)) {
          uint totalWritten = GetExtensionInfo(c, outputfile);
          outputfile.Close();
          if (totalWritten > 0) {
            SystemClass::Message(SystemClass::ICONINFORMATION, "File Created Sucessfully", "File saved at '" + OutputFilePath + "'");
            Console.WriteLine("Create Input file for Search and Carve completed successfully");
          }
          else {
#ifdef VERSION_7
            SystemClass::Message(SystemClass::ICONEXCLAMATION, "No keywords found!", "Did you select tags?");
            Console.WriteLine("No keywords found! Did you select tags?");
#else
            SystemClass::Message(SystemClass::ICONEXCLAMATION, "No keywords found!", "Did you select entries?");
            Console.WriteLine("No keywords found! Did you select entries?");
#endif
          }
        }
        else {
          Console.WriteLine("Could not open file '" + OutputFilePath + "' for writing");
        }
      }
    }
  }
}
