/*

Last Updated: 06 December 2012
Version     : 1.5

Updated By  : Lightbox Technologies, Inc.
              http://www.lightboxtechnologies.com
              info@lightboxtechnologies.com

Author      : Yogesh Khatri
              42 LLC
              Yogesh@42LLC.net

For         : Sgt. Glenn Lang
              Maine State Police
              207-877-8081
              glang@mcctf.org

*/


/* CarveSizeDialogClass
   This class represents a dialog that dynamically
   changes the number of controls it displays
   depending on the number of unique extensions
   in the input file provided.
*/
class CarveSizeDialogClass : DialogClass {
  typedef String[]          StringArray;
  typedef StringEditClass[] StringEditArray;
  typedef int[]             IntArray;
  typedef IntEditClass[]    IntEditArray;

  NameValueClass  Items;
  StringArray     Strings;
  IntArray        Ints;
  StringEditArray StringEdits;
  IntEditArray    IntEdits;
  StaticTextClass Text1,
                  Text2;

  CarveSizeDialogClass(NameValueClass items):
    DialogClass(null, "Define Keyword offset for extensions"),
    Items = items,
    Strings(0, items.Count()),
    Ints(0, items.Count()),
    StringEdits(0, items.Count()),
    IntEdits(0, items.Count()),
    Text1(this, "Extension", 20, 10, 40, 12, 0),
    Text2(this, "Keyword Offset(Bytes)", NEXT, SAME, 100, 12, 0)
  {
    CreateEditBoxes();
  }

  void CreateEditBoxes() {

    int x = 20, y = 25;

    uint numItems = Items.Count();
    for (int i = 0; i < numItems; ++i) {
      Strings.Add(Items.GetChild(i).Name());
      Ints.Add(int::Convert(Items.GetChild(i).Value()));
      StringEdits.Add(new StringEditClass(this, "", x, y, 40, 10, READONLY, Strings[i], 128, 0));
      IntEdits.Add(new IntEditClass(this, "", x + 55, y, 80, 10, 0, Ints[i], 0, 1073741824, REQUIRED));

      y += 15;
    }
  }

  virtual bool CanClose() {
    if (DialogClass::CanClose()) {
      Output();
      uint numItems = Items.Count();
      for (int i = 0; i < numItems; ++i) {
        Items.GetChild(i).SetValue(Ints[i]);
      }
      return true;
    }
    return false;
  }
}

class MainClass {
  /* This function displays a dialog to the user where extension offsets
     are to be populated. The retrieved information is then passed onto
     the required data structures (SearchTerms).
  */

  String GetKeyword(EntryClass e, uint offset) {
    String keyword;
    EntryFileClass file();
    if (file.Open(e)) {
      file.Seek(offset);
      for (int i = 0; i < 10; ++i) {
        int onebyte = file.ReadBinaryInt(1);
        keyword += "\\x" + String::FormatInt(onebyte, int::HEX, 0, 2);
      }
      file.Close();
    }
    else
      Console.WriteLine("Error , could not open file " + e.FullPath());
    return keyword;
  }

  void addToList(NameValueClass nv, const String& ext) {
    if (!nv.Find(ext)) {
      new NameValueClass(nv, ext, 0, "10"); // Converts search term extension to NameValue object for dialog
    }
  }

  void generateKeywords(NameValueClass nv, EntryClass e, uint& total, FileClass outputFile) {
    NameValueClass n = nv.Find(e.Extension());
    if (n) {
      uint offset = uint::Convert(n.Value()); // populate searchterm object from NameValue object
      if (offset == 0 ) Console.WriteLine("Warning : Offset was zero for entry = " + e.FullPath());
      String keyword = GetKeyword(e, offset);
      if (!keyword) {
        Console.WriteLine("Error, keyword could not be extracted");
      }
      else {
        outputFile.Write(keyword + "\t" +
                         e.Extension() + "\t" +
                         offset + "\t" +
                         e.LogicalSize() + "\r\n"
                         );
        total++;
      }
    }
    else {
      Console.WriteLine("Error, could not find value for entry " + e.FullPath());
    }
  }

  uint GetExtensionInfo(CaseClass c, FileClass outputFile) {
    SystemClass::StatusMessage("Waiting for dialog input. Check taskbar for dialog!");
    uint total;
    NameValueClass nv();
#ifdef VERSION_7
    ItemIteratorClass iter(c, ItemIteratorClass::PROMPT, ItemIteratorClass::TAGGED);
    SystemClass::StatusMessage("Getting extensions");
    while (EntryClass e = iter.GetNextEntry()) {
      if (!e.IsFolder() && !e.IsInternal() && !e.IsUnallocated()) {
        addToList(nv, e.Extension());
      }
    }
#else
    SystemClass::StatusMessage("Getting extensions");
    forall (EntryClass e in c.EntryRoot()) {
      if (e.IsSelected() && !e.IsFolder() && !e.IsInternal() && !e.IsUnallocated()) {
        addToList(nv, e.Extension());
      }
    }
#endif
    CarveSizeDialogClass d(nv);
    SystemClass::StatusMessage("Waiting for dialog input. Check taskbar for dialog!");
    if (d.Execute() == SystemClass::OK) { // display dialog
    SystemClass::StatusMessage("Writing file");
    ulong count;
#ifdef VERSION_7
      iter.Open(c, 0, ItemIteratorClass::TAGGED, iter.Name()); //reset with same tag selections
      while (EntryClass e = iter.GetNextEntry()) {
        if (!e.IsFolder() && !e.IsInternal() && !e.IsUnallocated()) {
          ++count;
          SystemClass::StatusMessage("Writing file (" + count + " lines)");
          generateKeywords(nv, e, total, outputFile);
        }
      }
#else
      forall (EntryClass e in c.EntryRoot()) {
        if (e.IsSelected() && !e.IsFolder() && !e.IsInternal() && !e.IsUnallocated()) {
          ++count;
          SystemClass::StatusMessage("Writing file (" + count + " lines)");
          generateKeywords(nv, e, total, outputFile);
        }
      }
#endif
    }
    return total;
  }

  void Main(CaseClass c) {
    bool good = true;
    if (!c) {
      SystemClass::Message(SystemClass::ICONEXCLAMATION, "No Case", "There is no case active, please open a case.");
      good = false;
    }
#ifdef VERSION_7
    if (c.HasEvidenceList()==0) {
      SystemClass::Message(SystemClass::ICONEXCLAMATION, "No Evidence", "You do not appear to have evidence in your case.\n\nPlease load some evidence first.");
      good = false;
    }
#else
    if (!c.EntryRoot() || !c.EntryRoot().FirstChild() || !c.EntryRoot().FirstChild().FirstChild()) {
      SystemClass::Message(SystemClass::ICONEXCLAMATION, "Nothing loaded", "No evidence present in this case!\nPlease load some evidence first.");
      good = false;
    }
#endif
    if (good) {
      uint result;
#ifdef VERSION_7
      String v7Msg = "In v7, this script operates on tagged entries.\n\nYou must have previously tagged the relevant entries AND know the tag name. " +
                     "You will be prompted to select the tag name(s).\n\nIf you have not tagged any entries, please hit Cancel and do so now.";
      result = SystemClass::Message(SystemClass::ICONINFORMATION | SystemClass::MBOKCANCEL, "Create Input file for Search & Carve Script", v7Msg);
#else
      String v6Msg = "Select all entries in encase from which you wish to extract keywords, then press OK to continue";
      result = SystemClass::Message(SystemClass::ICONINFORMATION | SystemClass::MBOKCANCEL, "Create Input file for Search & Carve Script", v6Msg);
#endif
      if (result != SystemClass::CANCEL) {
        String filepath;
        if (SystemClass::PathDialog(filepath, "Enter path to save output file to ", "*.ini", "Tab-delimitted file\0*.ini\0", SystemClass::CREATE) == SystemClass::OK) {
          SystemClass::ClearConsole();
          LocalFileClass outputfile();
          if (outputfile.Open(filepath, FileClass::WRITE | FileClass::TEXT)) {
            uint totalWritten = GetExtensionInfo(c, outputfile);
            outputfile.Close();
            if (totalWritten > 0) {
              SystemClass::Message(SystemClass::ICONINFORMATION, "File Created Sucessfully", "File saved at '" + filepath + "'");
            }
            else {
              SystemClass::Message(SystemClass::ICONEXCLAMATION, "No keywords found!", "File saved at '" + filepath + "'");
            }
          }
          else {
            Console.WriteLine("Could not open file '" + filepath + "' for writing");
          }
        }
      }
    }
  }
}
